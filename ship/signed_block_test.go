package ship_test

import (
	"bytes"
	"io"
	"testing"
	"time"

	"github.com/shufflingpixels/antelope-go/abi"
	"github.com/shufflingpixels/antelope-go/chain"
	"github.com/shufflingpixels/antelope-go/internal/assert"
	"github.com/shufflingpixels/antelope-go/ship"
)

var signedBlock = ship.SignedBlock{
	SignedBlockHeader: ship.SignedBlockHeader{
		BlockHeader: chain.BlockHeader{
			Timestamp: chain.NewBlockTimestamp(time.UnixMilli(1234567890)),
			Producer:  chain.N("producer"),
			Confirmed: 13,
			Previous: chain.Checksum256{
				0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			},
			TransactionMRoot: chain.Checksum256{
				0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			},
			ActionMRoot: [32]byte{
				0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			},
			ScheduleVersion:  23,
			NewProducersV1:   &chain.ProducerSchedule{},
			HeaderExtensions: nil,
		},
		ProducerSignature: chain.Signature{
			Type: chain.K1,
			Data: []byte{
				0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
				0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
				0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
				0xff,
			},
		},
	},
	Transactions: []ship.TransactionReceipt{
		{
			TransactionReceiptHeader: chain.TransactionReceiptHeader{
				Status:               chain.TransactionStatusHardFail,
				CPUUsageMicroSeconds: 123,
				NetUsageWords:        7281,
			},
			Trx: ship.Transaction{
				TxId: &chain.Checksum256{
					0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
					0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
				},
			},
		},
	},
	BlockExtensions: []ship.Extension{
		{
			Type: 12,
			Data: []byte{0x01, 0x02},
		},
	},
}

var signedBlockEncoded = []byte{
	0x10, 0x26, 0x4b, 0x8f, 0x0, 0x0, 0x0, 0x57, 0x21, 0x9d, 0xe8, 0xad, 0xd, 0x0, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x17, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0xff, 0x1, 0x2, 0x7b, 0x0, 0x0, 0x0, 0xf1, 0x38, 0x0, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x1, 0xc, 0x0, 0x2, 0x1, 0x2,
}

func TestSignedBlockEncode(t *testing.T) {
	buf := new(bytes.Buffer)
	enc := abi.NewEncoder(buf, abi.DefaultEncoderFunc)
	err := enc.Encode(signedBlock)
	assert.NoError(t, err)

	data, err := io.ReadAll(buf)
	assert.NoError(t, err)
	assert.Equal(t, data, signedBlockEncoded)
}

func TestSignedBlockDecode(t *testing.T) {
	actual := ship.SignedBlock{}
	err := abi.NewDecoder(bytes.NewBuffer(signedBlockEncoded), abi.DefaultDecoderFunc).Decode(&actual)
	assert.NoError(t, err)

	assert.Equal(t, actual, signedBlock)
}

func TestSignedBlockBytesEncode(t *testing.T) {
	buf := new(bytes.Buffer)
	enc := abi.NewEncoder(buf, abi.DefaultEncoderFunc)
	err := enc.Encode(ship.SignedBlockBytes(signedBlockEncoded))
	assert.NoError(t, err)

	data, err := io.ReadAll(buf)
	assert.NoError(t, err)
	assert.Equal(t, data, append([]byte{0xea, 0x1}, signedBlockEncoded...))
}

func TestSignedBlockBytesDecode(t *testing.T) {
	data := append([]byte{0xea, 0x1}, signedBlockEncoded...)
	actual := ship.SignedBlockBytes{}
	err := abi.NewDecoder(bytes.NewBuffer(data), abi.DefaultDecoderFunc).Decode(&actual)
	assert.NoError(t, err)

	assert.Equal(t, actual, ship.SignedBlockBytes(signedBlockEncoded))
}

func TestSignedBlockBytesUnpack(t *testing.T) {
	sbb := ship.SignedBlockBytes(signedBlockEncoded)
	actual := ship.SignedBlock{}
	assert.NoError(t, sbb.Unpack(&actual))
	assert.Equal(t, actual, signedBlock)
}
